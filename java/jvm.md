#  Java虚拟机（ Java Virtual Machine ）

------

## 1、类加载机制

类加载器的父子结构：根加载器—>扩展类加载器—>应用程序加载器—>自定义加载器

*内容：*

​	在使用某类加载器加载类的二进制文件进入内存的时候，首先会使用根加载器进行加载，如果不能加载的话再逐层往下递归，直至到达指定的类加载器后才加载该类。

*意义*

​	双亲委派机制的意义在于，我们自己写的类会覆盖系统本身内部的类，造成系统内部程序的混乱，例如`java.lang.object`类，

------

## 2、synchronize在代码块锁、方法锁、类锁的区别

​	Java的关键字，用它来修饰一个方法或者是一段代码块的时候，可以保证同一时间内只有一个县城可以访问该方法；

1. ​	修饰实例方法，相当于给当前的对象实例加锁，进入同步代码块之前要获得当前对象锁

   ​	该方法指的是把synchronize关键字放在实例方法上，用于修饰非静态方法；

   ​	

   ```java
       public synchronized void method(){
           System.out.println("线程"+Thread.currentThread().getName());
       }
   ```

   

2. ​    修饰静态方法，相当于给当前的类对象加锁，每次进入同步代码时候要获取该对象

3. ​    修饰代码块，制定加锁对象，对给定对象加锁，进入代码块之前获取该对象锁

   第一种：不同的对象

   ```java
       public void run(){
           synchronized (lock1){
   			do something
           }
           synchronized (lock2){
    			do something	
           }
       }
   ```

   上述的两个synchronize所包括的代码块是相互不影响的，因为使用着两个不同的锁对象。

------

## 3、JVM GC算法

jvm虚拟机主要是为了解决程序中哪些需要回收、怎么回收、回收的时机是什么时候;

1. 哪些需要回收，这个问题主要是明确在jvm中哪些对象是垃圾对象，这里最主要设计到两种算法

   - <font color="#EE7AE9">引用计数算法（已经弃用）</font>

     特点：一种比较简单直观的算法，效率高

     原理：对象有一个引用，那么计数+1,删除一个引用计数-1，只收集计数为0的对象

     缺点：

     ​		<1>、互相引用的两个对象的计数器不为0，但是这个两个对象都已经属于无用的对象，这样会出现死锁的情况，占用内存。

     ​		<2>、由于引用计数算法需要计算每个对象被引用的次数，所以需要编译器的帮忙为每个对象装配计数器，增加了内存了占用率。

   - <font color="#EE7AE9">跟搜索算法</font>

     特点：解决引用计数出现的问题

     原理：在若干对象中，从任意跟对象到这个对象是不可达的状态的时候，那么这个对象就是属于可以回收的状态，

     跟对象：

     ​			1>、虚拟机栈中的引用对象。

     ​			2>、方法区中静态属性引用的对象。

     ​			3>、方法区中常亮引用的对象。

     ​			4>、本地方法栈JNI引用的对象。

2. 怎么回收，“哪些需要回收”中的两种算法已经解决了什么是“垃圾“的事情，这里所讲的算法是如何处理垃圾

   - <font color="#EE7AE9">复制算法</font>

     复制算法是将内存分成两片不同的区域，在任何时间点内，所动态分配的对象1只能存在于其中的一片区域内（活动区域)，而另一片的区域则是空闲（空闲区域），当活动区域的空间被动态分配的对象耗尽的时候，JVM会暂停线程，启动GC复制线程，GC线程更新存活对象的内存引用地址指向空闲的区域，这时候空闲区域就变成了活动区域，原来在旧活动区域的垃圾对象就会被清除，

     缺点：第一个是由于垃圾算法的特点，实际内存的使用率只有50%，造成内存空间的浪费。

     ​		   第二个是当某个对象的生存时间非常长的时候，复制算法来回的切换引用地址会造成性能的下降

   - <font color="#EE7AE9">标记-清除算法</font>

     标记清除算法操作比较简单，当有效空间快要被耗尽的时候，JVM就会遍历所有的对象进行标记垃圾对象的操作，遍历完之后就会清除所有的垃圾对象，剩下存活对象，算法结束。

     缺点：由于每次直接删除垃圾对象，会造成剩下的物理地址不是连续的，一旦有比较大的对象分配进入来之后；虽然有效空间的大小是可以分配进去这个比较新的对象的，但是由于地址不是连续的，所以这个对象就无法分配。

   - <font color="#EE7AE9">标记-整理算法</font>

     标记整理算法有两个过程，标记+整理

     和标记清除一样的GC过程，都是遍历所有的GC Root，标记可达的存活对象，但是会多出“整理”的过程，这个整理的过程实际上就是对存活下来的对象的物理地址进行整理，呈现有序的状态，这样就不用了担心有较大的对象进入之后无法分配对象的时候；

     缺点：虽然已经解决了标记清除带来内存的物理地址排列紊乱的情况，但是这个问题却被转化成每次标记整理的时候都需要进行相应的数据整理所带来时间增加的情况。

   - <font color="#EE7AE9">分代收集算法</font>

     分代算法的实际上并没有产生任何新的GC算法，只是将内存的区域进行划分，对不同的地方使用不同的GC策略。

     - 对象类型：

       ​	夭折对象（局部变量/循环内的临时变量）

       ​	老不死对象（缓存对象/数据库连接对象/单例对象...)

       ​	永恒对象（String池中的对象/类加载信息)

     - 对象内存的区域：

       ​	Java堆：夭折对象和老不死对象都生存在Java堆里面

       ​	方法区：永恒对象所在区域

     - Java堆区域划分详解：

       ​	Java堆主要分成两片区域：1/3的区域用于构建新生代、2/3的区域用于构建老年代，其中新生代又分成from:to:Eden = 1:1:8  from和to主要适用于复制算法，而Eden使用的算法是标记整理或者是标记清除

     - GC过程：每次对象都会在新生代中的Eden中产生，在进行younger GC的时候就会进入到from或者是to的区域内，年龄+1,在之后的younge GC的过程中都会对对象的年龄进行+1,当年龄达到一定的年龄的时候就会进入到老年代中，而老年代的对象由于存活时间一般都比较长，所以采用的GC算法是标记整理或者是标记清除的算法。

     - 对象的转换情况：

       ​	1、新生代每次GC都会伴随着年龄的增长，到达一定的年龄后直接进入到老年代中。

       ​	2、当内存无法容纳新的对象的时候，也会进入到老年代，所以老年代是新生代的备用仓库。

       ​	3、永恒对象只存在于方法区中，不存在与Java堆中任意位置

3. 什么时候进行回收

   young gc：当新生代不足以分配内存给新生的对象的时候，就会触发一次young gc,在进行young gc前，程序会判断老年代内连续空间是否大于新生代所有对象的总和，如果不是那么就启动full gc，

   full gc:

   - 老年代空间不足以分配内存的时候，当创建一个新的对象时候，如果新生代的80%的空间不足以分配的时候会直接进入到老年代，如果此时老年代的空间不足以分配内存的时候就会触发full gc。
   - 当永久代的空间已满的时候，再往永久代填入对象的时候就会触发full gc。
   - 显示调用System.gc，显示调用会在调用full gc前会先调用一次young gc

------






































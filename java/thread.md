# <font color="#9c3">多线程</font>

------

## 1、synchronize锁和Lock锁的区别

​	1、synchronize的自动释放锁，但是Lock必须手动进行释放，所以这就引发一个问题，如果程序在中间抛出异常，那么相对于synchronize来说，Lock就不会进行unlock，所以每次的解锁都必须放进finally里面进行。

​	2、Lock有共享锁的功能，所以可以设置读写锁来提高效率，但是synchronize不能。

​	3、Lock锁的事代码块，而synchronize锁不只是代码块还可以是方法锁还有类锁。

​	4、Lock可以知道线程有没有获取到锁，但是synchronize不能。

------

##  2、synchronize在jdk1.6是如何进行优化的

1. ​	适应自旋锁，为了减少线程状态改变带来的改变，不停的执行当前线程。
2. ​    锁消除，不可能进行共享数据竞争的锁进消除。
3. ​    锁粗化，对于连续加锁的操作，优化成只加一把锁。
4. ​    轻量级锁，在无竞争条件下，通过CAS进行消除同步互斥
5. ​    偏向锁，在无竞争条件下，消除同步互斥，连CAS都不操作

------

## 3、关于CyclicBarrier的使用介绍

- 从字面来看，Cyclic（可循环利用）Barrier（屏障）。它的功能是让一组线程到达屏障或者是公共点之后被阻塞。直到最后一个线程也到达屏障时，才会打开屏障，所有被屏障拦截的线程才会继续运行。
- 每一个Cyclic类里面都有一个计数器，当一个线程进来之后调用await方法，计数器-1，当计数器归0的时候，放开栅栏；执行所有线程。这就是cyclicBarrier的拦截原理

------




























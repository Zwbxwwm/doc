# <font color ="red">算法</font>

------

1、输入一个数字n，输出所有和为n的连续正数序列

例如：n = 15, 则应该输出<1,2,3,4,5> <4,5,6> <7,8>

定义两个变量start和end，初始化start = 0，end = 1；

操作：

1、遍历start和end里面的数字求和，得到total，

​2、如果total<n,end++,total>n，start++，

终止条件：end>n/2+1

------

2、求子数组的最大和 （要求时间复杂度为O(n) ）

例如数组a：{1，-3，4，-2，5，2，-10}   子数组的最大和为9

定义一个临时状态的一维数组b，和目标值max

操作，1、遍历a，如果a[n+1] + b[n] > a[n+1], 则b[n+1] = a[n+1] + b[n], 否则b[n+1] = a[n+1]。

​	       2、如果b[n+1] > max;    max = b[n+1],

a：{1，-3，4，-2，5，2，-10}

b：{1，-2，4，2，7，9，-1}

终止条件：遍历结束

------

3、求子数组的最大积

例如数组a：{1，-3，4，-2，5，2，-10}   子数组的最大积为200

定义一个临时状态的二维数组b，和目标值max

操作，1、b数组的第一维存储最大值，而第二维存储最小值，

​		   2、遍历数组a，如果a[n+1] < 0; 。。。。； 如果a[n+1] > 0。。。。;

终止条件：遍历结束

------

4、变量互换（不借助临时变量）

1.  算术算法

``` java
int a = 3, b = 4;
a = a+b; // a= 3+4 = 7
b = a-b; // b= (3+4)-4 = 3
a = a-b; // a= (3+4)-3 = 4
```

此算法与标准算法相比，多了三个计算的过程，但是没有借助临时变量

2.  异或算法

``` java
int a = 3, b = 4;
a = a^b;
b = a^b;
a = a^b;
```

此算法能够实现是由异或运算的特点决定的，通过异或运算能够使数据中的某些位翻转，其他位不变。这就意味着任意一个数与任意一个给定的值**连续异或两次，值不变**。 即：a^b^b=a。

将a=a^b代入b=a^b则得b=a^b^b=a;同理可以得到a=b^a^a=b;轻松完成交换。

异或运算最大的好处是直接进行二进制数据操作，大大节约了转换的时间效率。

------

5、删除链表的倒数第K个结点（不知道链表长度，只遍历一次链表）

实现思路
设置两个指向头结点的指针，让其中一个指针先走K步，然后让另一个指针同时一起走，找到倒数第K个结点，将第K个结点的值与倒数第K个节点的下一个节点的值相互替换，删除倒数第K个结点的下一个结点；

-----

6、找出数组中只出现一次的那个数，其他都出现两次。

使用**异或**（即"^"符号）
``` java
public int singleNumber(int[]arr){
    int result = 0;
    for(int i : arr){
        result ^= i
    }
    return result
}

```

## 排序算法

![排序算法对比](../images/sort_compare.jpg)

### 1、冒泡排序

### 2、选择排序

### 3、插入排序

### 4、希尔排序

### 5、归并排序

### 6、快速排序

### 7、堆排序

### 8、桶排序

### 9、基数排序

## 二叉树的遍历

### 深度优先遍历

#### 前序遍历

#### 中序遍历

#### 后序遍历

### 广度优先遍历

## 动态规划

